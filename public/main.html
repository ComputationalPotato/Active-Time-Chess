<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Chessboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
    <link rel="stylesheet" href="styles.css"> <!-- Link to external CSS file -->
</head>
<div id="drawModal" class="modal">
    <div class="modal-content">
        <h2>Draw Request</h2>
        <p>Your opponent has requested a draw. Do you accept?</p>
        <button id="acceptDraw">Yes</button>
        <button id="declineDraw">No</button>
    </div>
</div>

<style>
    .modal {
        display: none;
        position: fixed;
        z-index: 1;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
    }

    .modal-content {
        margin: 15% auto;
        padding: 20px;
        width: 80%;
        background: white;
        text-align: center;
    }
</style>

<body>
    <div class="board-container">
        <div id="myBoard"></div>
        <svg class="cooldown-overlay" id="cooldownOverlay"></svg>
    </div>
    <div class="button-container">
        <button id="startBtn">Start Position</button>
        <button id="clearBtn">Clear Board</button>
        <button id="resignBtn">Resign</button>
        <button id="drawBtn">Request Draw</button>
    </div>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.js"></script>


    <script type="module">
        import { updateCooldownCircle, updateOverlaySize, isLegalMove, isPathBlocked, afterMove, showGameEndMessage } from './gamelogic.js';

        let board = null;
        const COOLDOWN_TIME = 3000;
        const pieceCooldowns = new Map();
        let squareSize = 0;
        let playerColor = 'white'; // Default color


        var config = {
            draggable: true,
            position: 'start',
            onDrop: function (source, target, piece, newPos, oldPos, orientation) {
                console.log('Attempting move from ' + source + ' to ' + target);

                if (!isLegalMove(source, target, piece, newPos, oldPos)) {
                    console.log('Illegal move attempted');
                    return 'snapback';
                }

                // Record the move and check for promotion
                const promotedPiece = afterMove(source, target, piece, newPos);

                // If there was a promotion, update the position
                if (promotedPiece) {
                    newPos[target] = promotedPiece;
                }

                // Check if this was a castling move
                if (piece.charAt(1).toLowerCase() === 'k' && Math.abs(target.charCodeAt(0) - source.charCodeAt(0)) === 2) {
                    // Calculate rook's movement
                    const rank = source.charAt(1);
                    const isKingside = target.charAt(0) === 'g';
                    const oldRookFile = isKingside ? 'h' : 'a';
                    const newRookFile = isKingside ? 'f' : 'd';
                    const rookSource = `${oldRookFile}${rank}`;
                    const rookTarget = `${newRookFile}${rank}`;

                    // Update position to include rook movement
                    newPos[rookTarget] = newPos[rookSource];
                    delete newPos[rookSource];
                }

                socket.emit('move', {
                    source,
                    target,
                    piece: promotedPiece || piece, // Use promoted piece if available
                    newPosition: newPos
                });

                console.log('Move successful');
                return true;
            },
            onDragStart: function (source, piece, position, orientation) {
                // Check if piece is on cooldown
                if (pieceCooldowns.has(source) && Date.now() < pieceCooldowns.get(source)) {
                    return false;
                }

                // Only allow moving pieces of player's color
                const pieceColor = piece.charAt(0) === 'w' ? 'white' : 'black';
                return pieceColor === playerColor;
            },
            onChange: function (oldPos, newPos) {
                console.log('Board position changed');
            }
        };
        //this needs to be at the start to prevent race condition
        board = Chessboard('myBoard', config);

        // Initialize Socket.IO
        const socket = io();
        let gameId = new URLSearchParams(window.location.search).get('game');
        if (!gameId) {
            try {
                let response = await socket.timeout(10000).emitWithAck('lfg');
                gameId=response.gameId;
                console.log("got resp to lfg")
            } catch (e) {
                // the server did not acknowledge the event in the given delay
                console.log(e)
                console.log("aaaaaaaaaaaaaaaaa")
            }
        }
        
        socket.emit('joinGame', gameId);
        
        // Add game ID to URL without reloading
        if (!window.location.search.includes('game=')) {
            window.history.pushState({}, '', `?game=${gameId}`);
        }


        // Socket event handlers


        socket.on('gameJoined', (data) => {
            console.log('Joined game as', data.color);
            playerColor = data.color;
            board.orientation(data.color);
            board.position(data.position);

            // Apply any existing cooldowns
            data.cooldowns.forEach(([square, time]) => {
                if (Date.now() < time) {
                    pieceCooldowns.set(square, time);
                    const piece = board.position()[square];
                    if (piece) {
                        updateCooldownCircle(piece, square);
                    }
                }
            });
        });

        socket.on('moveMade', (data) => {
            board.position(data.position);
            pieceCooldowns.set(data.cooldown.square, data.cooldown.time);
            updateCooldownCircle(data.piece, data.cooldown.square);
        });

        socket.on('boardReset', (data) => {
            board.position(data.position);
            pieceCooldowns.clear();
            $('.cooldown-circle').remove();
        });

        socket.on('boardCleared', () => {
            board.clear();
            pieceCooldowns.clear();
            $('.cooldown-circle').remove();
        });

        socket.on('playerDisconnected', (data) => {
            console.log('Player disconnected, remaining players:', data.remainingPlayers);
        });
        socket.on('gameOver', (data) => {
            showGameEndMessage(data.winner, "resign");
        });

        // Initialize board and UI
        $(document).ready(function () {
            updateOverlaySize();

            $('#startBtn').on('click', function () {
                socket.emit('resetBoard');
            });

            $('#clearBtn').on('click', function () {
                socket.emit('clearBoard');
            });

            $('#resignBtn').on('click', function () {
                socket.emit('resign');
            });

            $('#drawBtn').on('click', function () {
                console.log('Requesting draw');
                socket.emit('requestDraw');
            });

            // Show modal when a draw request is received
            socket.on('drawRequest', () => {
                $('#drawModal').show();
            });

            // Handle the response buttons in the modal
            $('#acceptDraw').on('click', function () {
                $('#drawModal').hide();
                socket.emit('acceptDraw');
            });
            $('#declineDraw').on('click', function () {
                $('#drawModal').hide();
                socket.emit('declineDraw');
            });

            // Handle accepted and declined draw responses
            socket.on('drawAccepted', () => {
                console.log('Draw accepted, ending game');
                showGameEndMessage("Draw", "draw");
            });

            socket.on('drawDeclined', () => {
                console.log('Draw declined');
                alert("Your draw request was declined.");
            });


            $(window).resize(function () {
                board.resize();
                updateOverlaySize();
            });
        });

    </script>
</body>

</html>